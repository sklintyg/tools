kind: Template
apiVersion: v1
metadata:
  name: pipelinetemplate-test-webapp
parameters:
  - name: APP_NAME
    required: true
  - name: STAGE
    required: true
    value: "test"
  - name: BUILD_TEMPLATE
    required: true
    value: "buildtemplate-webapp"
  - name: DEPLOY_TEMPLATE
    required: true
    value: "deploytemplate-webapp"
  - name: TESTRUNNER_TEMPLATE
    required: true
    value: "testrunnertemplate-pod"
  - name: ARTIFACT_IMAGE_SUFFIX
    required: true
    value: "artifact"
  - name: SECRET
    required: true
  - name: TESTS
    value: "-"
    required: true
  - name: BACKING_SERVICES
    value: "-"
    required: true
  - name: CONTEXT_PATH
    required: true
    value: ROOT
  - name: HEALTH_URI
    required: true
    value: /
objects:
  - apiVersion: v1
    kind: BuildConfig
    metadata:
      name: ${APP_NAME}-pipeline
      generation: 1
      labels:
        app: ${APP_NAME}
        stage: ${STAGE}
    spec:
      triggers:
        - generic:
            allowEnv: true
            secret: ${SECRET}
          type: Generic
      strategy:
        jenkinsPipelineStrategy:
          type: JenkinsPipeline
          jenkinsfile: |-
            // The following variables are expected to be injected (from trigger) into the environment:
            // [ gitUrl, gitRef, buildVersion, infraVersion ]
            //
            // Build and Deploy temaples must previously have been installed
            //
            def dbName = "${APP_NAME}-${new Random().nextInt() % 1000}".replace('-', '')
            def localCommonVersion = "NA"
            def dbScript(cmd) {
              sh (
                script: "oc rsh \$(oc get pods | grep mysql- | grep Running | awk \'{ print \$1 }\')  bash -c \"mysql -u root -e \'${cmd}\'\"",
                returnStatus: true 
              ) 
            }
            pipeline {
              agent any
              stages {

                stage('Prepare') {
                  steps {
                    script {
                      echo "Prepare configuration and check pre-conditions"
                      openshift.withCluster() {
                        openshift.withProject() {
                          echo "Pipeline started with:"
                          echo "gitUrl: ${gitUrl}, gitRef: ${gitRef}"
                          if (env.commonVersion) {
                            localCommonVersion = env.commonVersion
                          }
                          echo "buildVersion: ${buildVersion}, infraVersion: ${infraVersion}, commonVersion: ${localCommonVersion}"
                          // check envrionment
                          [ env.gitUrl, env.gitRef, env.buildVersion, env.infraVersion ].each {
                            if (!it) {
                              error("No such required context variable in environment.")
                            }
                          }

                          [ "${BUILD_TEMPLATE}", "${DEPLOY_TEMPLATE}", "${TESTRUNNER_TEMPLATE}" ].each {
                            def t = openshift.selector("template", it)
                            if (!t.exists()) {
                              error("No such required template: ${it}")
                            }
                          }

                          // database
                          def status = dbScript("create database ${dbName} character set utf8mb4;")
                          if (status != 0) {
                            error("Unable to create database ${dbName}")
                          }                           
                        }
                      }
                    }
                  }
                }

                stage('Create Build Configuration') {
                  when {
                    expression {
                      return true
                    }                      
                  }
                  steps {
                    script {
                      openshift.withCluster() {
                        openshift.withProject() {
                          def models = openshift.process("${BUILD_TEMPLATE}", 
                            "-p", "APP_NAME=${APP_NAME}", 
                            "-p", "STAGE=${STAGE}",
                            "-p", "GIT_URL=${env.gitUrl}", 
                            "-p", "GIT_REF=${env.gitRef}",
                            "-p", "BUILD_VERSION=${env.buildVersion}", 
                            "-p", "INFRA_VERSION=${env.infraVersion}",
                            "-p", "COMMON_VERSION=${localCommonVersion}",
                            "-p", "CONTEXT_PATH=${CONTEXT_PATH}",
                            "-p", "ARTIFACT_IMAGE_SUFFIX=${ARTIFACT_IMAGE_SUFFIX}")
                          openshift.apply(models)
                        }
                      }
                    }
                  }
                }

                stage('Build App Artifact Image') {
                  when {
                    expression {
                      return true
                    }                      
                  }
                  steps {
                    script {
                      openshift.withCluster() {
                        openshift.withProject() {
                          echo "Build artifact image ${APP_NAME}-${ARTIFACT_IMAGE_SUFFIX}"
                          def build = openshift.selector("bc", "${APP_NAME}-${ARTIFACT_IMAGE_SUFFIX}").startBuild()                          
                          sleep(time: 1, unit: 'SECONDS')
                          echo "${build.name()} started" 
                          timeout (20) {
                            def status = ""
                            build.untilEach(1) {
                                status = it.object().status.phase
                                echo "Build status: ${status}" 
                                return !["Running", "Pending", "New"].contains(status)                            
                            }
                            echo "Logs for artifact build"
                            build.logs()
                            if (status != "Complete") {
                              error("Build terminated with status: ${status}")
                            }
                            echo "Build Completed"
                          }
                        }
                      }
                    }
                  }
                }


                stage('Build App Runtime Image') {
                  when {
                    expression {
                      return true
                    }                      
                  }
                  steps {
                    script {
                      openshift.withCluster() {
                        openshift.withProject() {
                          echo "Build runtime image ${APP_NAME}"
                          def build = openshift.selector("bc", "${APP_NAME}").startBuild()
                          sleep(time: 1, unit: 'SECONDS')
                          echo "${build.name()} started" 
                          timeout (5) {
                            def status = ""
                            build.untilEach(1) {
                                status = it.object().status.phase
                                echo "Build status: ${status}" 
                                return !["Running", "Pending", "New"].contains(status)                            
                            }
                            echo "Logs for docker runtime build"
                            build.logs()
                            if (status != "Complete") {
                              error("Build terminated with status: ${status}")
                            }
                            echo "Build Completed"
                          }
                        }
                      }
                    }
                  }
                }
                
                stage('Deploy App') {
                  when {
                    expression {
                      return true
                    }                      
                  }
                  steps {
                    script {
                      openshift.withCluster() {
                        openshift.withProject() {
                          def imageStream = openshift.selector("is", "${APP_NAME}").object().status.dockerImageRepository
                          echo "Use ImageStream: ${imageStream}"
                          def deployModel = openshift.process("${DEPLOY_TEMPLATE}", 
                            "-p", "APP_NAME=${APP_NAME}", 
                            "-p", "IMAGE='$imageStream:${env.buildVersion}'",
                            "-p", "DATABASE_NAME=${dbName}",
                            "-p", "HEALTH_URI=${HEALTH_URI}",
                            "-p", "STAGE=${STAGE}")                          
                          echo "Wait for rollout (limited to 5 minutes)"
                          timeout (5) {
                            def rm = openshift.apply(deployModel).narrow("dc").rollout()
                            echo "Waiting for deployment to complete"
                            rm.status()
                            echo "Deployment done."
                          }

                        }
                      }
                    }
                  }      
                }

              stage('Deploy Backing Services') {
                  when {
                      expression {
                        if ("${BACKING_SERVICES}" == "-") {
                          return false
                        }
                          return true
                      }
                  }
                  steps {
                      script {
                          openshift.withCluster() {
                              openshift.withProject() {
                                  "${BACKING_SERVICES}".split(",").each {
                                      def imageStream = openshift.selector("is", "${it}-verified").object().status.dockerImageRepository
                                      echo "Use ImageStream: ${imageStream}"
                                      def healthUri = "/"
                                      // FIXME: dirty work-around!
                                      if (it.startsWith("intygstjanst")) {
                                          healthUri += "inera-certificate"
                                      }
                                      def backDbName = "${it.replace('-', '')}${dbName}"
                                      def status = dbScript("create database ${backDbName} character set utf8mb4;")
                                      if (status != 0) {
                                          error("Unable to create database ${backDbName}")
                                      }

                                      def svcAppName = "${it}-${APP_NAME}"

                                      def rc = 0

                                      // Configmap for /$STAGE/config
                                      rc = sh (
                                        script: "oc get configmap ${it}-config -o yaml --export | sed \'s/name: ${it}-config/name: ${svcAppName}-config/g\' | oc apply -f -",
                                        returnStatus: true
                                      )
                                      if (rc  != 0) {
                                        error("Unable to create configmap ${svcAppName}-config")
                                      }

                                      // Secret for /$STAGE/env
                                      rc = sh (
                                        script: "oc get secret ${it}-env -o yaml --export | sed \'s/name: ${it}-env/name: ${svcAppName}-env/g\' | oc apply -f -",
                                        returnStatus: true
                                      )
                                      if (rc  != 0) {
                                        error("Unable to create secret ${svcAppName}-env")
                                      }

                                      // Certificates /$STAGE/certifikat
                                      rc = sh (
                                        script: "oc get secret ${it}-certifikat -o yaml --export | sed \'s/name: ${it}-certifikat/name: ${svcAppName}-certifikat/g\' | oc apply -f -",
                                        returnStatus: true
                                      )
                                      if (rc  != 0) {
                                        error("Unable to create secret ${svcAppName}-certifikat")
                                      }

                                      // Secret for envvars
                                      rc = sh (
                                        script: "oc get secret ${it}-secret-envvar -o yaml --export | sed \'s/name: ${it}-secret-envvar/name: ${svcAppName}-secret-envvar/g\' | oc apply -f -",
                                        returnStatus: true
                                      )
                                      if (rc  != 0) {
                                        error("Unable to create secret ${svcAppName}-secret-envvar")
                                      }

                                      // Config-map for envvars
                                      rc = sh (
                                        script: "oc get configmap ${it}-configmap-envvar -o yaml --export | sed \'s/name: ${it}-configmap-envvar/name: ${svcAppName}-configmap-envvar/g\' | oc apply -f -",
                                        returnStatus: true
                                      )
                                      if (rc  != 0) {
                                        error("Unable to create configmap ${svcAppName}-configmap-envvar")
                                      }

                                      def deployModel = openshift.process("deploytemplate-webapp",
                                              "-p", "APP_NAME=${svcAppName}",
                                              "-p", "IMAGE='$imageStream:latest'",
                                              "-p", "DATABASE_NAME=${backDbName}",
                                              "-p", "HEALTH_URI=${healthUri}",
                                              "-p", "STAGE=test")
                                      echo "Wait for rollout (limited to 5 minutes)"
                                      timeout(5) {
                                          def rm = openshift.apply(deployModel).narrow("dc").rollout()
                                          echo "Waiting for deployment to complete"
                                          rm.status()
                                          echo "Deployment done."
                                      }
                                  }
                              }
                          }
                      }
                  }
              }


            /* START TESTS */

              // RESTASSURED
                stage('Run restAssuredTest Tests') {
                  when {
                    expression {
                      if ("${TESTS}".contains("restAssuredTest")) {
                        return true
                      }
                      return false
                    }                      
                  }
                  steps {
                    script {
                      openshift.withCluster() {
                        openshift.withProject() {
                          echo "Do test"

                          // Setup callback webhook
                          def hook = registerWebhook()

                          // Just use name
                          def targetUrl = "http://${APP_NAME}:8080"                         

                          def imageStream = openshift.selector("is", "${APP_NAME}").object().status.dockerImageRepository
                          echo "Use ImageStream: ${imageStream}"

                          // to make the pod name somewhat unique
                          // TODO: use generateName in Pod template, i.e. when it works
                          def num = (new Random().nextInt() % 100000) + 1
                          def suffix = (num < 0) ? "${num}" : "-${num}"
                          def pod = openshift.process("${TESTRUNNER_TEMPLATE}",
                            "-p", "APP_NAME=${APP_NAME}", 
                            "-p", "IMAGE='${imageStream}-${ARTIFACT_IMAGE_SUFFIX}:${env.buildVersion}'", 
                            "-p", "STAGE=${STAGE}",                          
                            "-p", "TARGET_URL='${targetUrl}'",
                            "-p", "BUILD_VERSION=${env.buildVersion}", 
                            "-p", "JOB_NAME=${env.JOB_NAME}",
                            "-p", "CALLBACK_URL='${hook.getURL()}'",
                            "-p", "BUILD_TAG=${env.BUILD_TAG}${suffix}",
                            "-p", "TESTS=restAssuredTest")
                          openshift.apply(pod)
                          
                          def data = ""
                          timeout (30) {
                            echo "Waiting (max 30 min) for POST to ${hook.getURL()}"
                            data = waitForWebhook(hook).trim()

                            [ "restAssuredTest"].each { t ->
                              if ("${TESTS}".contains("${t}")) {
                                echo "Publishing ${t} reports for ${JOB_NAME}/${env.buildVersion}"
                                publishHTML([
                                  allowMissing: true,
                                  alwaysLinkToLastBuild: true,
                                  keepAll: true,
                                  reportDir: "/var/lib/jenkins/reports/$JOB_NAME/${env.buildVersion}/${t}/",
                                  reportFiles: "${t}.html",
                                  reportName: "${t.capitalize()} Results",
                                ])
                              }
                            }
                          }
                          echo "Logs for ${env.BUILD_TAG}${suffix}"
                          openshift.selector( "pod", "${env.BUILD_TAG}${suffix}" ).logs()

                          if ("SUCCESS".equals(data)) {
                            echo "Test SUCCESS"
                          } else {
                            error("Tests FAILED, see reports for any details")
                          }
                        }
                      }
                    }
                  }
                }
                // END RESTASSURED


               // PROTRACTOR
               stage('Run Protractor Tests') {
                 when {
                   expression {
                     if ("${TESTS}".contains("protractorTest")) {
                       return true
                     }
                     return false
                   }
                 }
                 steps {
                   script {
                     openshift.withCluster() {
                       openshift.withProject() {
                         echo "Do test"

                         // Setup callback webhook
                         def hook = registerWebhook()

                         // Just use name
                         def targetUrl = "http://${APP_NAME}:8080"

                         def imageStream = openshift.selector("is", "${APP_NAME}").object().status.dockerImageRepository
                         echo "Use ImageStream: ${imageStream}"

                         // to make the pod name somewhat unique
                         // TODO: use generateName in Pod template, i.e. when it works
                         def num = (new Random().nextInt() % 100000) + 1
                         def suffix = (num < 0) ? "${num}" : "-${num}"
                         def pod = openshift.process("${TESTRUNNER_TEMPLATE}",
                           "-p", "APP_NAME=${APP_NAME}",
                           "-p", "IMAGE='${imageStream}-${ARTIFACT_IMAGE_SUFFIX}:${env.buildVersion}'",
                           "-p", "STAGE=${STAGE}",
                           "-p", "TARGET_URL='${targetUrl}'",
                           "-p", "BUILD_VERSION=${env.buildVersion}",
                           "-p", "JOB_NAME=${env.JOB_NAME}",
                           "-p", "CALLBACK_URL='${hook.getURL()}'",
                           "-p", "BUILD_TAG=${env.BUILD_TAG}${suffix}",
                           "-p", "TESTS=protractorTest")
                         openshift.apply(pod)

                         def data = ""
                         timeout (30) {
                           echo "Waiting (max 30 min) for POST to ${hook.getURL()}"
                           data = waitForWebhook(hook).trim()

                           [ "protractorTest" ].each { t ->
                             if ("${TESTS}".contains("${t}")) {
                               echo "Publishing ${t} reports for ${JOB_NAME}/${env.buildVersion}"
                               publishHTML([
                                 allowMissing: true,
                                 alwaysLinkToLastBuild: true,
                                 keepAll: true,
                                 reportDir: "/var/lib/jenkins/reports/$JOB_NAME/${env.buildVersion}/${t}/",
                                 reportFiles: "${t}.html",
                                 reportName: "${t.capitalize()} Results",
                               ])
                             }
                           }
                         }
                         echo "Logs for ${env.BUILD_TAG}${suffix}"
                         openshift.selector( "pod", "${env.BUILD_TAG}${suffix}" ).logs()

                         if ("SUCCESS".equals(data)) {
                           echo "Test SUCCESS"
                         } else {
                           error("Tests FAILED, see reports for any details")
                         }
                       }
                     }
                   }
                 }
               }
               // END protractorTest




            // FITNESSE
             stage('Run Fitnesse Tests') {
               when {
                 expression {
                   if ("${TESTS}".contains("fitnesseTest")) {
                     return true
                   }
                   return false
                 }
               }
               steps {
                 script {
                   openshift.withCluster() {
                     openshift.withProject() {
                       echo "Do test"

                       // Setup callback webhook
                       def hook = registerWebhook()

                       // Just use name
                       def targetUrl = "http://${APP_NAME}:8080"

                       def imageStream = openshift.selector("is", "${APP_NAME}").object().status.dockerImageRepository
                       echo "Use ImageStream: ${imageStream}"

                       // to make the pod name somewhat unique
                       // TODO: use generateName in Pod template, i.e. when it works
                       def num = (new Random().nextInt() % 100000) + 1
                       def suffix = (num < 0) ? "${num}" : "-${num}"
                       def pod = openshift.process("${TESTRUNNER_TEMPLATE}",
                         "-p", "APP_NAME=${APP_NAME}",
                         "-p", "IMAGE='${imageStream}-${ARTIFACT_IMAGE_SUFFIX}:${env.buildVersion}'",
                         "-p", "STAGE=${STAGE}",
                         "-p", "TARGET_URL='${targetUrl}'",
                         "-p", "BUILD_VERSION=${env.buildVersion}",
                         "-p", "JOB_NAME=${env.JOB_NAME}",
                         "-p", "CALLBACK_URL='${hook.getURL()}'",
                         "-p", "BUILD_TAG=${env.BUILD_TAG}${suffix}",
                         "-p", "TESTS=fitnesseTest")
                       openshift.apply(pod)

                       def data = ""
                       timeout (30) {
                         echo "Waiting (max 30 min) for POST to ${hook.getURL()}"
                         data = waitForWebhook(hook).trim()

                         [ "fitnesseTest" ].each { t ->
                           if ("${TESTS}".contains("${t}")) {
                             echo "Publishing ${t} reports for ${JOB_NAME}/${env.buildVersion}"
                             publishHTML([
                               allowMissing: true,
                               alwaysLinkToLastBuild: true,
                               keepAll: true,
                               reportDir: "/var/lib/jenkins/reports/$JOB_NAME/${env.buildVersion}/${t}/",
                               reportFiles: "${t}.html",
                               reportName: "${t.capitalize()} Results",
                             ])
                           }
                         }
                       }
                       echo "Logs for ${env.BUILD_TAG}${suffix}"
                       openshift.selector( "pod", "${env.BUILD_TAG}${suffix}" ).logs()

                       if ("SUCCESS".equals(data)) {
                         echo "Test SUCCESS"
                       } else {
                         error("Tests FAILED, see reports for any details")
                       }
                     }
                   }
                 }
               }
             }
             // END fitnesseTest




              // CYPRESS
             stage('Run cypressTest Tests') {
               when {
                 expression {
                   if ("${TESTS}".contains("cypressTest")) {
                     return true
                   }
                   return false
                 }
               }
               steps {
                 script {
                   openshift.withCluster() {
                     openshift.withProject() {
                       echo "Do test"

                       // Setup callback webhook
                       def hook = registerWebhook()

                       // Just use name
                       def targetUrl = "http://${APP_NAME}:8080"

                       def imageStream = openshift.selector("is", "${APP_NAME}").object().status.dockerImageRepository
                       echo "Use ImageStream: ${imageStream}"

                       // to make the pod name somewhat unique
                       // TODO: use generateName in Pod template, i.e. when it works
                       def num = (new Random().nextInt() % 100000) + 1
                       def suffix = (num < 0) ? "${num}" : "-${num}"
                       def pod = openshift.process("${TESTRUNNER_TEMPLATE}",
                         "-p", "APP_NAME=${APP_NAME}",
                         "-p", "IMAGE='${imageStream}-${ARTIFACT_IMAGE_SUFFIX}:${env.buildVersion}'",
                         "-p", "STAGE=${STAGE}",
                         "-p", "TARGET_URL='${targetUrl}'",
                         "-p", "BUILD_VERSION=${env.buildVersion}",
                         "-p", "JOB_NAME=${env.JOB_NAME}",
                         "-p", "CALLBACK_URL='${hook.getURL()}'",
                         "-p", "BUILD_TAG=${env.BUILD_TAG}${suffix}",
                         "-p", "TESTS=cypressTest")
                       openshift.apply(pod)

                       def data = ""
                       timeout (30) {
                         echo "Waiting (max 30 min) for POST to ${hook.getURL()}"
                         data = waitForWebhook(hook).trim()

                         [ "cypressTest" ].each { t ->
                           if ("${TESTS}".contains("${t}")) {
                             echo "Publishing ${t} reports for ${JOB_NAME}/${env.buildVersion}"
                             publishHTML([
                               allowMissing: true,
                               alwaysLinkToLastBuild: true,
                               keepAll: true,
                               reportDir: "/var/lib/jenkins/reports/$JOB_NAME/${env.buildVersion}/${t}/",
                               reportFiles: "${t}.html",
                               reportName: "${t.capitalize()} Results",
                             ])
                           }
                         }
                       }
                       echo "Logs for ${env.BUILD_TAG}${suffix}"
                       openshift.selector( "pod", "${env.BUILD_TAG}${suffix}" ).logs()

                       if ("SUCCESS".equals(data)) {
                         echo "Test SUCCESS"
                       } else {
                         error("Tests FAILED, see reports for any details")
                       }
                     }
                   }
                 }
               }
             }
             // END cypressTest


            /* END TESTS */
                
                stage('Promote Image to Nexus') {
                  steps {
                    script {
                      openshift.withCluster() {
                        openshift.withProject() {
                          def imageStream = openshift.selector("is", "${APP_NAME}").object().status.dockerImageRepository
                          echo "Use ImageStream: ${imageStream}"

                          def model = openshift.process("buildtemplate-nexus",
                            "-p", "APP_NAME=${APP_NAME}", 
                            "-p", "IMAGE='${imageStream}'", 
                            "-p", "STAGE=${STAGE}",                          
                            "-p", "TAG='${env.buildVersion}'")
                          openshift.apply(model)

                          def build = openshift.selector("bc", "${APP_NAME}-nexus").startBuild()
                          echo "${build.name()} started"
                          def status = ""
                          timeout (20) {

                            build.untilEach(1) {
                                status = it.object().status.phase
                                echo "Build status: ${status}" 
                                return !["Running", "Pending", "New"].contains(status)                            
                            }

                            echo "Logs for nexus build"
                            build.logs()
                            if (status != "Complete") {
                              error("Build terminated with status: ${status}")
                            }  
                          }                 
                        }
                      }
                    }
                  }
                }
              }

              post {
                success {
                  script {
                    openshift.withCluster() {
                      openshift.withProject() { 
                          def source = openshift.selector("is", "${APP_NAME}").object().status.dockerImageRepository
                          def project = openshift.project()
                          def target = "${project}/${APP_NAME}-verified"
                          echo "Promote image ${source} to is ${APP_NAME}-verified"
                          openshift.tag("${source}:${env.buildVersion}", "${target}:${env.buildVersion}", "${target}:latest")
                      }
                    }
                  }              
                }

                always {
                  script {
                    echo "cleanup"
                    openshift.withCluster() {
                      openshift.withProject() {
                        dbScript("drop database ${dbName};")

                        echo "Logs for ${APP_NAME}"
                        openshift.selector( "dc", "${APP_NAME}" ).logs()

                        def image = openshift.selector("is", "${APP_NAME}").object()
                        def imageStream = image.status.dockerImageRepository
                        sh (
                          script: "oc process ${DEPLOY_TEMPLATE} -p APP_NAME=\"${APP_NAME}\" -p IMAGE=\"${imageStream}:${env.buildVersion}\" -p STAGE=${STAGE} -p DATABASE_NAME=${dbName} | oc delete -f -",
                          returnStdout: true
                        )

                        if ("${BACKING_SERVICES}" != "-") {
                            "${BACKING_SERVICES}".split(",").each {
                                def svcAppName = "${it}-${APP_NAME}"
                                echo "Logs for ${svcAppName}"
                                openshift.selector( "dc", "${svcAppName}" ).logs()

                                imageStream = openshift.selector("is", "${it}-verified").object().status.dockerImageRepository
                                def backDbName = "${it.replace('-', '')}${dbName}"
                                sh (
                                  script: "oc process ${DEPLOY_TEMPLATE} -p APP_NAME=\"${svcAppName}\" -p IMAGE=\"${imageStream}:latest\" -p STAGE=${STAGE} -p DATABASE_NAME=${backDbName} | oc delete -f -",
                                  returnStdout: true
                                )
                                dbScript("drop database ${backDbName};")

                                // Delete /config configmap
                                sh (
                                  script: "oc delete configmap ${svcAppName}-config",
                                  returnStdout: true
                                )
                                // Delete /env secret
                                sh (
                                  script: "oc delete secret ${svcAppName}-env",
                                  returnStdout: true
                                )
                                // Delete /certifikat secret
                                sh (
                                  script: "oc delete secret ${svcAppName}-certifikat",
                                  returnStdout: true
                                )
                                // Delete configmap envvar
                                sh (
                                  script: "oc delete configmap ${svcAppName}-configmap-envvar",
                                  returnStdout: true
                                )
                                // Delete secret envvar
                                sh (
                                  script: "oc delete secret ${svcAppName}-secret-envvar",
                                  returnStdout: true
                                )
                            }
                        }
                      }
                    }
                  }                  
                }

                failure {
                  echo "Pipeline Failed :("
                }

              }
            }
        
      



